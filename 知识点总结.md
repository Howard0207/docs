# 知识点总结

## Worker

> 兼容性

PC： IE 10+

Phone: no support

> 创建

```js
const worker = new Worker(path) // 返回一个worker对象
```

> 销毁

```js
// 有以下三种方式
// 1. 主页面
worker.terminate();
// 2. 自销毁
self.close()
// 3. 关闭页面
```

> 内部引用文件的方法

使用importScripts加载文件，并可以动态加载文件。

> 环境

worker拥有一个独立的运行环境Workerglobalscope

* 局限性

  * 同源限制。不能跨域加载js
  * dom限制。worker内代码不能访问dom
  * 文件限制。子线程无法读取本地文件，即worker只能加载网络文件。
  * 各个浏览器对worker的实现不大一致， 例如FF允许worker中创建新的worker，而Chrome不行
  * 通信限制。Worker线程和主线程不在同一个上下文环境，他们不能直接通信，必须通过消息完成。

* API

  ```js
  worker.onerror： 指定 error 事件的监听函数。
  worker.onmessage： 指定 message 事件的监听函数， 发送过来的数据在 Event.data 属性中。
  worker.onmessageerror： 指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时， 会触发这个事件。
  worker.postMessage： 向 worker 线程发送消息。
  worker.terminate： 立即终止 worker 线程。
  ```

* worker 线程 API

  ```js
  self.name： Worker 的名字。该属性制度， 由构造函数指定。
  self.onmessage： 指定 message 事件的监听函数。
  self.onmessageerror： 指定messageerror事件的监听函数。 发送的数据无法序列化成字符串时，会触发这个事件。
  self.close：关闭worker线程。
  self.postMessage： 向产生这个 worker 线程发送消息。
  self.importScripts： 加载 js 脚本。
  ```



## ServiceWorker

Service Worker 是基于Web Worker的事件驱动的， 他们执行的极值都是新开的一个线程去处理一些额外的，以前不能直接处理的任务。对于Web Worker，我们可以使用它来进行复杂的计算，因为它并不阻塞浏览器主线陈的渲染。 而Service Worker，我们可以用它来进行本地缓存或者请求转发，相当于一个浏览器端本地的proxy。

> 1. 兼容性

> 2. 介绍

Service Worker Global Scope 部分作用域定义如下：

scriptCache： worker 的文件一旦注册使用， 会被缓存到浏览器中， 需要手动清理掉， 例如： 注册使用了 sw.js ， sw.js 修改后必须清理缓存后才生效。





## Promise

> 1. Promise.all



> 2. Promise.allsetted



> 3. Promise 原理



## BFC



## 手写Reduce



## 数组去重



## 箭头函数与普通函数的区别



## cors注意事项



## CSS 吸顶



## Hooks 解决的问题 ， 使用上的限制



## React-router 原理



## Event Loop



## 盒子模型



## HMR原理



## 防抖 节流







## setTimeout 和 dom 原生事件同步

问题与下面意思相同

## React 合成事件和原生事件的区别， 原生事件怎么设计

* 在组件声明周期或React合成事件 中， setState是异步的；（异步操作， 但特定情况下会执行一次， 性能被优化）
* 在 setTimeout 或者 原生dom 事件中， setState是同步；（完全是同步函数）

## setState 为什么异步执行

* setState 设计为异步，可以显著提升性能；

  如果每次调用setState都进行一次更新，意味着render函数会被频繁的调用，及诶按重新渲染，这样效率很低。

* 最好的办法是获取到多个更新， 之后进行批量更新；（这里有前端框架最初的设计时的思想，为了提高性能，减少操作dom次数，通过算法计算少次多亮地进行操作dom）

