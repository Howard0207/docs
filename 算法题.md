# 算法题

## 最长上升子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1

```js
// 动态规划
var lengthOfLIS = function (nums) {
	const len = nums.length;
	const dp = [];
	for (let i = 0; i < len; i++) {
		dp[i] = [];
		dp[i][i] = 1
	}
	for (let L = 2; L <= len; L++) {
		for (let i = 0; i < len; i++) {
			let j = L + i - 1;
			if (j >= len) {
				break;
			}
			if (nums[j] > nums[j - 1]) {
				if (j - i < 2) {
					dp[i][j] = 2;
				} else {
					dp[i][j] = dp[i][j - 1] + 1;
				}
			} else {
				dp[i][j] = dp[i][j - 1];
			}
		}
	}
	return dp[0][len - 1]
};


// 二分法 + 贪心算法
const len = nums.length;
let max = 1;
const dp = [nums[0]];
for (let i = 1; i < len; i++) {
    let target = nums[i];
    if (target > dp[max - 1]) {
        dp.push(target);
        max++;
        continue;
    }
    let l = 0;
    let r = dp.length - 1;
    while (l <= r) {
        let mid = l + ((r - l) >> 1);
        if (target > dp[mid]) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    dp[l] = target;
}
return max;
```

